---
title: "Tutorial: How to fine tune a Cellpose model"
author: Fernando Cervantes (fernando.cervantes@jax.org)
format:
  revealjs:
    code-fold: false
    progress: true
    controls: true
    fontsize: 22pt

  ipynb:
    roc: true

execute:
  echo:
    true

jupyter: python3
---

# 1 Image groups management

## 1.1 Load a sample image

You can use the cells 3D image sample from the napari's built-in samples.

```
File > Open Sample > napari builtins > Cells (3D+2Ch)
```

``` {python}
#| echo: false
from PIL import Image, ImageDraw, ImageFont
import napari
from napari.utils import nbscreenshot
import napari_activelearning as al
```
``` {python}
#| echo: false
viewer = napari.Viewer()
_ = viewer.open_sample(plugin="napari", sample="cells3d")
```
``` {python}
#| echo: false
nbscreenshot(viewer)
```

## 1.2 Add the _Image Groups Manager_ widget to napari's window

You can find the _Image group manager_ under the _Active Learning_ plugin in the napari's plugins menu.

```
Plugins > Active Learning > Image groups manager
```

``` {python}
#| echo: false
image_groups_mgr, acquisition_fun_cfg, labels_mgr = al.get_active_learning_widget()
```
``` {python}
#| echo: false
image_groups_mgr_dw = viewer.window.add_dock_widget(image_groups_mgr)
```
``` {python}
#| echo: false
nbscreenshot(viewer)
```

## 1.3 Create an _Image Group_ containing _nuclei_ and _membrane_ layers

- Select the _nuclei_ and _membrane_ layer and click the _New Image Group_ button on the _Image Groups Manager_ widget.

``` {python}
#| echo: false
viewer.layers.selection.clear()
viewer.layers.selection.add(viewer.layers["nuclei"])
viewer.layers.selection.add(viewer.layers["membrane"])
image_groups_mgr.create_group()
```
``` {python}
#| echo: false
nbscreenshot(viewer)
```

## 1.4 Edit the image group properties

:::: {.columns}

::: {.column width=0.3}
- Select the newly created image group, it will appear as "images" in the _Image groups manager_ widget.

- Click the _Edit group properties_ checkbox.

- Make sure that _Axes order_ is "CZYX", otherwise, you can edit it and press _Enter_ to update the axes names.
:::

::: {.column width=0.7}
``` {python}
#| echo: false
image_groups_mgr.image_groups_editor._show_editor(True)
image_groups_mgr._active_image_group.child(0).setSelected(True)
image_groups_mgr.image_groups_editor.edit_axes_le.setText("CZYX")
image_groups_mgr.image_groups_editor.update_source_axes()
```
``` {python}
#| echo: false
screenshot = viewer.screenshot(canvas_only=False, flash=False)

image = Image.fromarray(screenshot)

org_height, org_width = screenshot.shape[:2]

roi = (org_width * 0.7, 0, org_width, org_height)

# Crop the image
cropped_image = image.crop(roi)

draw = ImageDraw.Draw(cropped_image)

# Draw a red rectangle
draw.rectangle([70, 250, 310, 280], outline="white", width=5)
draw.rectangle([70, 250, 310, 280], outline="green", width=2)

cropped_image
```
:::

::::

# 2 Segment the managed image groups

## 2.1 Add the _Acquisition function configuration_ widget to napari's window

The _Acquisition function configuration_ is under the _Active Learning_ plugin in the napari's plugins menu.

```
Plugins > Active Learning > Acquisition function configuration
```

``` {python}
#| echo: false
acquisition_fun_cfg_dw = viewer.window.add_dock_widget(acquisition_fun_cfg)
viewer.window._qt_window.tabifyDockWidget(image_groups_mgr_dw, acquisition_fun_cfg_dw)

image_groups_mgr_dw.setWindowTitle("Image groups manager")
acquisition_fun_cfg_dw.setWindowTitle("Acquisition function configuration")
```
``` {python}
#| echo: false
acquisition_fun_cfg_dw.raise_()
```
``` {python}
#| echo: false
nbscreenshot(viewer)
```

## 2.2 Define sampling configuration

:::: {.columns}

::: {.column width=0.3}
### 2.2.1 Set the axes of the sampling space

1. Make sure "Input axes" are set to "ZYX"

::: {.callout-note}
This specifies that the samples will be taken from those axes.
:::

2. Change the "Model axes" to "YXC"

::: {.callout-note}
The model axes are the axes on which the segmentation model is implemented. `Cellpose` (for 2D images) expects the input image to have "Y" and "X" spatial axes, and a trailing channel axes "C".
:::

:::

::: {.column width=0.3}

``` {python}
#| echo: false
acquisition_fun_cfg.input_axes_le.setText("ZYX")
acquisition_fun_cfg._set_input_axes()
acquisition_fun_cfg.model_axes_le.setText("YXC")
acquisition_fun_cfg._set_model_axes()
```
``` {python}
#| echo: false
screenshot = viewer.screenshot(canvas_only=False, flash=False)

image = Image.fromarray(screenshot)

org_height, org_width = screenshot.shape[:2]

roi = (org_width * 0.7, 0, org_width, org_height)

# Crop the image
cropped_image = image.crop(roi)

draw = ImageDraw.Draw(cropped_image)

draw.rectangle([60, 435, 405, 475], outline="white", width=5)
draw.rectangle([60, 435, 405, 475], outline="green", width=2)

position = (250, 395)
font = ImageFont.truetype("arialbd.ttf", size=36)
draw.text(position, "1", fill="green", font=font)
font = ImageFont.truetype("arial.ttf", size=36)
draw.text(position, "1", fill="white", font=font)

draw.rectangle([405, 435, 570, 475], outline="white", width=5)
draw.rectangle([405, 435, 570, 475], outline="green", width=2)

position = (490, 395)
font = ImageFont.truetype("arialbd.ttf", size=36)
draw.text(position, "2", fill="green", font=font)
font = ImageFont.truetype("arial.ttf", size=36)
draw.text(position, "2", fill="white", font=font)

cropped_image
```
:::

::::

---

### 2.2.2 Set the size of the sampling patch

:::: {.columns}

::: {.column width=0.70}

``` {python}
#| echo: false
acquisition_fun_cfg._show_patch_sizes(True)

acquisition_fun_cfg.patch_sizes_mspn.sizes = {"Z": 1, "Y": 256, "X": 256}
```
``` {python}
#| echo: false
screenshot = viewer.screenshot(canvas_only=False, flash=False)

image = Image.fromarray(screenshot)

org_height, org_width = screenshot.shape[:2]

roi = (org_width * 0.7, 0, org_width, org_height)

# Crop the image
cropped_image = image.crop(roi)

draw = ImageDraw.Draw(cropped_image)

# Draw a red rectangle
draw.rectangle([70, 270, 470, 700], outline="white", width=5)
draw.rectangle([70, 270, 470, 700], outline="green", width=2)

cropped_image
```

:::

::: {.column width=0.30}

- Click the "Edit patch size" checkbox
- Change the patch size of "X" and "Y" to 256, and the "Z" axis to 1.

:::{.callout-note}
This directs the Active Learning plugin to sample at random patches of size $256\times256$ pixels, and $1$ slice of depth.
:::

:::

::::

## 2.3 Define the maximum number of samples to extract

:::: {.columns}

::: {.column width=0.7}

``` {python}
#| echo: false
acquisition_fun_cfg.max_samples_spn.setValue(4)
```
``` {python}
#| echo: false
screenshot = viewer.screenshot(canvas_only=False, flash=False)

image = Image.fromarray(screenshot)

org_height, org_width = screenshot.shape[:2]

roi = (org_width * 0.7, 0, org_width, org_height)

# Crop the image
cropped_image = image.crop(roi)

draw = ImageDraw.Draw(cropped_image)

# Draw a red rectangle
draw.rectangle([60, 855, 405, 890], outline="white", width=5)
draw.rectangle([60, 855, 405, 890], outline="green", width=2)

cropped_image.resize((int(0.15 * org_width), int(org_height * 0.5)), Image.Resampling.LANCZOS)
```

:::

::: {.column width=0.30}
- Set the "Maximum samples" to $4$ and press _Enter_

:::{.callout-note}
This tells the Active Learning plugin to process at most _four_ samples at random from the whole image.
:::

:::

::::


## 2.4 Configure the segmentation method

:::: {.columns}

::: {.column width=0.3}

1. Use the dropdown with label "None selected" to select the `cellpose` method

2. Click the "Advanced segmentation parameters" checkbox

3. Change the second channel to 1 (the right spin box in the "channels" row)

::: {.callout-note}
This tells `cellpose` to segment the first channel ($0$) and use the second channel ($1$) as help channel.
:::

:::

::: {.column width=0.7}
``` {python}
#| echo: false
acquisition_fun_cfg.methods_cmb.setCurrentIndex(2)
acquisition_fun_cfg.tunable_segmentation_method.advanced_segmentation_options_chk.setChecked(True)
acquisition_fun_cfg.tunable_segmentation_method._segmentation_parameters.channels.value = (0, 1)
```
``` {python}
#| echo: false
screenshot = viewer.screenshot(canvas_only=False, flash=False)

image = Image.fromarray(screenshot)

org_height, org_width = screenshot.shape[:2]

roi = (org_width * 0.7, 0, org_width, org_height)

# Crop the image
cropped_image = image.crop(roi)

draw = ImageDraw.Draw(cropped_image)

# Draw a red rectangle
draw.rectangle([55, 550, 570, 580], outline="white", width=5)
draw.rectangle([55, 550, 570, 580], outline="green", width=2)

position = (550, 580)
font = ImageFont.truetype("arialbd.ttf", size=36)
draw.text(position, "1", fill="green", font=font)
font = ImageFont.truetype("arial.ttf", size=36)
draw.text(position, "1", fill="white", font=font)

draw.rectangle([65, 585, 310, 620], outline="white", width=5)
draw.rectangle([65, 585, 310, 620], outline="green", width=2)

position = (320, 580)
font = ImageFont.truetype("arialbd.ttf", size=36)
draw.text(position, "2", fill="green", font=font)
font = ImageFont.truetype("arial.ttf", size=36)
draw.text(position, "2", fill="white", font=font)

draw.rectangle([390, 750, 550, 780], outline="white", width=5)
draw.rectangle([390, 750, 550, 780], outline="green", width=2)

position = (450, 710)
font = ImageFont.truetype("arialbd.ttf", size=36)
draw.text(position, "3", fill="green", font=font)
font = ImageFont.truetype("arial.ttf", size=36)
draw.text(position, "3", fill="white", font=font)

cropped_image.resize((int(0.15 * org_width), int(org_height * 0.5)), Image.Resampling.LANCZOS)
```
:::

::::

## 2.5 Execute the segmentation method on all image groups

:::: {.columns}

::: {.column width=0.3}
- Click the "Run on all image groups"

::: {.callout-note}
To execute the segmentation only on specific image groups, select the desired image groups in the _Image groups manager_ widget and use the "Run on selected image groups" button instead.
:::

:::

::: {.column width=0.7}
``` {python}
#| echo: false
screenshot = viewer.screenshot(canvas_only=False, flash=False)

image = Image.fromarray(screenshot)

org_height, org_width = screenshot.shape[:2]

roi = (org_width * 0.7, 0, org_width, org_height)

# Crop the image
cropped_image = image.crop(roi)

draw = ImageDraw.Draw(cropped_image)

# Draw a red rectangle
draw.rectangle([225, 970, 385, 1005], outline="white", width=5)
draw.rectangle([225, 970, 385, 1005], outline="green", width=2)

cropped_image.resize((int(0.15 * org_width), int(org_height * 0.5)), Image.Resampling.LANCZOS)
```
``` {python}
#| echo: false
_ = acquisition_fun_cfg.compute_acquisition_layers(run_all=True)
```
:::

::::

## 2.6 Inspect the segmentation layer

::: {.callout-note}
Because the input image is 3D, you might have to slide the Z index on the bottom of napari's window to look at the samples that have been segmented.
:::

``` {python}
#| echo: false
labels_mgr.focus_region(
  labels_mgr.labels_group_root.child(0).child(0)
)
```
``` {python}
#| echo: false
screenshot = viewer.screenshot(canvas_only=False, flash=False)

image = Image.fromarray(screenshot)

draw = ImageDraw.Draw(image)

# Draw a red rectangle
draw.rectangle([295, 1080, 1380, 1110], outline="white", width=5)
draw.rectangle([295, 1080, 1380, 1115], outline="green", width=2)

image
```


# 3 Segment masked regions only

## 3.1 Create a mask to restrict the sampling space

### 3.1.1 Add a mask layer to the image group

:::: {.columns}
::: {.column width=0.3}
- Switch to the "Image groups manager" tab
- Click the "Edit mask properties" checkbox
:::

::: {.column width=0.7}
``` {python}
#| echo: false
image_groups_mgr_dw.raise_()
```
``` {python}
#| echo: false
screenshot = viewer.screenshot(canvas_only=False, flash=False)

image = Image.fromarray(screenshot)

org_height, org_width = screenshot.shape[:2]

roi = (org_width * 0.7, 0, org_width, org_height)

# Crop the image
cropped_image = image.crop(roi)

draw = ImageDraw.Draw(cropped_image)

# Draw a red rectangle
draw.rectangle([45, 375, 220, 410], outline="white", width=5)
draw.rectangle([45, 375, 220, 410], outline="green", width=2)

cropped_image
```
``` {python}
image_groups_mgr.mask_generator._show_editor(True)
```

:::

::::

### 3.1.2 Create a low resolution mask for the associated image

:::: {.columns}
:::{.column width=0.3}
1. Set the mask scale to $256$ for the "X" and "Y" axes, and a scale of $1$ for the "Z" axis

2. Click the "Create mask" button

:::{.callout-note}
This creates a low-resolution mask where each pixel corresponds to a $256\times256$ pixels region in the input image.
Because the mask is low-resolution, it uses less space (in memory RAM and disk).
:::

:::

:::{.column width=0.7}
``` {python}
#| echo: false
image_groups_mgr.mask_generator.patch_sizes_mspn.sizes = {"Z": 1, "Y": 256, "X": 256}
image_groups_mgr.mask_generator.generate_mask_layer()
```
``` {python}
#| echo: false
screenshot = viewer.screenshot(canvas_only=False, flash=False)

image = Image.fromarray(screenshot)

org_height, org_width = screenshot.shape[:2]

roi = (org_width * 0.7, 0, org_width, org_height)

# Crop the image
cropped_image = image.crop(roi)

draw = ImageDraw.Draw(cropped_image)

# Draw a red rectangle
draw.rectangle([60, 450, 550, 640], outline="white", width=5)
draw.rectangle([60, 450, 550, 640], outline="green", width=2)

position = (500, 400)
font = ImageFont.truetype("arialbd.ttf", size=36)
draw.text(position, "1", fill="green", font=font)
font = ImageFont.truetype("arial.ttf", size=36)
draw.text(position, "1", fill="white", font=font)

draw.rectangle([50, 675, 560, 710], outline="white", width=5)
draw.rectangle([50, 675, 560, 710], outline="green", width=2)

position = (530, 640)
font = ImageFont.truetype("arialbd.ttf", size=36)
draw.text(position, "2", fill="green", font=font)
font = ImageFont.truetype("arial.ttf", size=36)
draw.text(position, "2", fill="white", font=font)

cropped_image
```
:::
::::


## 3.1.3 Specify the samplable regions

- Draw a mask on slices $27$ to $30$ in the "Z" axis.

:::{.callout-note}
You can move the slider at the bottom of napari's window to navigate between slices in the "Z" axis.
:::

``` {python}
#| echo: false
viewer.camera.center = (27, 128, 128)
viewer.dims.current_step = (27, 128, 128)

viewer.layers["images mask"].data[0, 0, 27:31, 0, 0] = 1
viewer.layers["images mask"].refresh()
```
``` {python}
#| echo: false
screenshot = viewer.screenshot(canvas_only=False, flash=False)

image = Image.fromarray(screenshot)

image
```


## 3.2 Execute the segmentation process on the masked regions

:::: {.columns}
::: {.column width=0.3}
- Go back to the "Acquisition function configuration" widget
- Click the "Run on all image groups" button again

::: {.callout-note}
Because the image group has a defined mask, samples will be extracted at random inside those defined regions only.
:::

:::

::: {.column width=0.7}
``` {python}
#| echo: false
acquisition_fun_cfg_dw.raise_()
```
``` {python}
#| echo: false
screenshot = viewer.screenshot(canvas_only=False, flash=False)

image = Image.fromarray(screenshot)

org_height, org_width = screenshot.shape[:2]

roi = (org_width * 0.7, 0, org_width, org_height)

# Crop the image
cropped_image = image.crop(roi)

draw = ImageDraw.Draw(cropped_image)

# Draw a red rectangle
draw.rectangle([225, 970, 385, 1005], outline="white", width=5)
draw.rectangle([225, 970, 385, 1005], outline="green", width=2)

cropped_image.resize((int(0.15 * org_width), int(org_height * 0.5)), Image.Resampling.LANCZOS)
```
``` {python}
#| echo: false
_ = acquisition_fun_cfg.compute_acquisition_layers(run_all=True)
```

:::

::::

## 3.3 Inspect the masked segmentation output

``` {python}
#| echo: false
screenshot = viewer.screenshot(canvas_only=False, flash=False)

image = Image.fromarray(screenshot)
image
```
